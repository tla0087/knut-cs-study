# 프로세스의 개요

```
프로세스는 하나의 작업 단위이다. 아이콘을 더블클릭하여 프로그램을 실행하면
그 포르개름은 프로세스가 된다. 실행된 프로세스는 복잡한 과정을 거쳐 작업을
마무리 한다. 이 절에서는 OS의 프로세스 처리 과정을 살펴보자.
```

## 프로세스의 개념
- 프로그램과 프로세스의 차이
    + 프로그램 : 저장장치에 저장되어 있는 정적인 상태 (실행 전, 더블클릭 이전)
    + 프로세스 : 실행을 위해 메모리에 올라온 동적인 상태 (실행 후, 더블클릭 이후)
- 프로그램은 어떤 데이터를 사용하여 어떤 작업을 수행할지 절차를 적어놓은 것이다.
- 프로세스는 프로그램으로 작성된 작업 절차를 실제로 실행에 옮긴다는 의미이다.

<br>

## 프로그램에서 프로세스로의 전환
- 프로세스 : 컴퓨터 시스템의 작업 단위. 태스크(Task)라고도 부른다.
- 프로그램 -> 프로세스의 전환 순서
   1. 운영체제는 프로그램을 메모리의 적당한 위치로 가져온다.
   2. 작업 지시서인 프로세스 제어 블록이 생성된다.
   3. 전환 끗~
- 프로세스 제어 블록(Process Control Block)
   +  프로세스를 처리하는데 필요한 다양한 정보가 들어있다.
   +  PCB이 없으면 프로그램이 프로세스로 전환되지 못한다.
   +  어떤 프로그램이 프로세스가 되었다. = PCB를 받았다.
   +  프로세스 제어 블록의 대표적인 정보 세 가지
      * 프로세스 구분자(Process ID) : 각 프로세스를 구분할 수 있게 해주는 구분자이다. = 레스토랑 주문서의 일련번호
      * 메모리 관련 정보 : CPU는 실행하려는 프로세스가 메모리의 **어디**에 저장되어 있는지를 알아야 작업할 수 있다. 따라서, PCB에는 프로세스의 메모리 위치 정보가 담겨있다.
          - **메모리 보호를 위한 경계 레지스터와 한계 레지스터도 포함되어 있다.**
      * 각종 중간값 : 프로세스가 사용했던 중간 값이 저장된다. = 주문서에 어떤 단품 요리까지 나갔는지 체킹하는 것
          - 다음에 작업해야 할 코드의 위치가 담긴 레지스터인 프로그램 카운터도 저장된다.
          - 작업의 중간값을 보관 중인 다른 레지스터도 같이 저장된다.


### 결론
- 프로세스 제어 블록 = 프로세스 구분자 + 메모리 관련 정보 + 각종 중간값 + PC(Program Counter)
- 프로그램이 프로세스가 되려면 메모리에 올라오는 것과 동시에 프로세스 제어 블록이 생성되어야만 한다.
- **프로세스 제어 블럭은 메모리의 운영체제 영역에 만들어진다.**
- 프로세스가 종료되면 프로세스 제어 블록도 폐기된다.

```
프로세스 = 프로그램 + 프로세스 제어 블록
프로그램 = 프로세스 - 프로세스 제어 블록
```
- 프로세스에 대한 중요한 점 : 컴퓨터 내에는 사용자가 실행한 프로세스만 있는 것이 아니다. 
- 운영체제 => 결국 프로그램, 소프트웨어
  + 다른 프로그램처럼 똑같이 메모리에 올라와야 실행 가능
  + 프로세스가 되어야 실행 가능
  + 프로세스가 되기 위해선 똑같이 프로세스 제어 블록이 필요하다.
  + 운영체제의 프로세스 제어 블록은 누가 만들어줄까? => 부트스트랩
    * 부트스트랩이 운영체제 관련 프로세스를 실행한다.
- 결론) 컴퓨터 = 일반 사용자의 사용자 프로세스 + 운영체제의 커널 프로세스

<br>

## 프로세스의 상태
- 운영체제에서도 여러 가지 이유로 **프로세스 상태**가 변화된다.
- 일괄 작업 시스템의 경우 프로세스가 **생성**된 후 CPU를 얻어 **실행**되고 작업을 마치면 **종료**된다.
- 따라서, 일괄 작업 시스템의 프로세스 상태 = 생성(Create), 실행(Running), 완료(Terminate)
- 시분할 시스템은 CPU를 얻어 실행중인 프로세스가 중간에 다른 프로세스에 CPU를 넘겨주는 일이 빈번하다. 따라서, 시분할 시스템에서의 프로세스 상태는 복잡하다.

## 프로세스의 네 가지 상태
![FourStatus](https://ifh.cc/g/2rUVmE.jpg)

- 생성 상태(Create Status) : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태이다. 프로세스 제어 블록이 생성된다.
- 준비 상태(Ready Status) : 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태이다.
- 실행 상태(Running Status) : 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태이다. 실행 상태에 들어간 프로세스는 **일정 시간**동안 CPU를 사용할 권리를 갖는다. 만약 주어진 시간을 다 사용하고도 작업이 끝나지 않았다면 프로세스는 **준비 상태로 돌아와 다음 차례를 기다린다.** 자신의 **작업이 끝날 때까지 준비 상태와 실행 상태를 왔다갔다 한다.**
- 완료 상태(Terminate Status) : 실행 상태의 프로세스가 주어진 시간 동안 작업을 마치면 완료 상태로 진입한다. 완료 상태는 **프로세스 제어 블록이 사라진 상태**를 의미한다.

<br>

- 준비 상태에 있는 여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일은 **CPU 스케줄러(CPU Scheduler)가 담당**한다.
- CPU 스케줄러는 준비 상태의 맨 앞에서 기다리고 있는 프로세스 제어 블록을 CPU에 전달하여 작업이 이루어지게 한다.
- 준비 상태의 프로세스 중 하나를 골라 **실행 상태로 바꾸는 CPU 스케줄러의 작업**을 디스패치(Dispatch)라고 한다.
- CPU 스케줄러에 의해 선택된 프로세스는 실행 상태에서 일정 시간 동안 작업을 진행한다.
   + 여기서 '일정 시간'은 타임 슬라이스 or 타임 퀀텀이라고 부름
- 실행 상태에 들어간 프로세스가 일정 시간(타임 슬라이스)동안 작업을 끝내지 못하면 다시 **준비 상태로 돌아가는데 이를 타임아웃(Timeout)이라고 부른다.**
- 새로운 프로세스가 실행 상태로 들어오면 CPU는 일정 시간이 흐른 뒤 알려달라고 **클록에게 요청한다.**
- 일정 시간이 다 되면 클록은 **인터럽트를 사용하여** 일정 시간이 흘렀다고 CPU에게 알린다.

<br>

## 프로세스의 다섯 가지 형태
```
프로세스는 네 가지 상태만으로 작업을 진행해도 큰 문제가 없다. 하지만, 어떤 프로세스가
실행 상태에 들어가 입출력을 요구했다고 가정해보자. 프로세스가 입출력을 요구하면 CPU는
입출력 관리자에게 명령을 내린다.

이 상태에서 프로세스는 요청한 작업이 끝날 때까지 다음 작업을 진행 할 수 없다. 이렇게
될 경우, CPU도 아무 작업을 하지 않고 기다리게 되어 효율성이 떨어지게 되는데, 이를
해결하기 위해서 '대기 상태'가 추가되어 다섯 가지의 형태가 되었다.
```
- 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태를 **대기 상태(Blocking Status)라고 한다.
- 작업의 효율성을 늘리기 위해 실행 상태에 두지않고 대기 상태로 옮기게 되었다.
- 실행 상태에 있던 프로세스가 대기 상태로 옮겨지면 CPU 스케줄러는 준비 상태에 있는 프로세스 중 하나를 가져다 실행 상태로 만든다.

![FiveStatus](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpjKL3%2FbtqIkukDACv%2FdsTvOVWzXKk9Kx9tcQ3tp1%2Fimg.png)

- 대기 상태의 프로세스는 요청한 입출력이 완료되면 입출력 관리자로부터 인터럽트를 받는다.
- 대기 상태의 프로세스는 입출력이 완료되면 실행 상태로 돌아갈 것 같지만 그렇지 않다.
  + 대기 상태로 보낸 후, 다른 프로세스 제어 블록을 디스패치 해서 실행 상태로 올리기 때문이다.
  + 이미 실행 상태에서 또 다른 프로세스의 작업이 행해지고 있는데, 그걸 멈추고서 대기 상태의 프로세스를 실행 상태로 옮기는건 상당히 비효율적이다.

<br>

```
각 단계에 대한 설명에 들어가기에 앞서
PID = 프로세스 식별자를 의미한다.
```
- 생성 상태
  + 생성 상태(Create Status)는 프로그램이 메모리에 올라오고 운영체제로부터 프로세스 제어 블록을 할당받은 상태이다. 
- 준비 상태
  + 준비 상태(Ready Status)는 실행 대기 중인 모든 프로세스가 자기 순서를 기다리는 상태이다.
  + 프로세스 제어 블록은 준비 큐에서 기다리며 CPU 스케쥴러에 의해 관리된다.
  + CPU 스케줄러는 준비 상태에서 큐를 몇 개 운영할지, 큐에 있는 어떤 프로세스의 프로세스 제어 블록을 실행 상태로 보낼지를 결정한다.
  + CPU 스케줄러가 dispatch(PID)를 실행하면 해당 프로세스가 준비 상태에서 실행 상태로 바뀌어 작업이 이루어진다.

- 실행 상태
   + 실행 상태(Running Status)는 프로세스가 CPU를 할당받아 실행되는 상태이다.
   + 실행 상태에 들어가는 프로세스는 CPU의 개수 만큼이다.
   + 실행 상태에 있는 프로세스는 자신에게 주어진 시간동안만 작업할 수 있다 => 시간 전부 사용 시 timeout(PID) 실행
   + timeout(PID)는 프로세스 제어 블록을 실행 상태에서 준비 상태로 옮긴다.
   + 실행 상태 동안 작업이 완료되면 **exit(PID)가 시행되어 프로세스가 정상 종료 된다.**
   + 실행 상태에 있는 프로세스가 입출력을 요청하면 **CPU는 입출력 관리자에게 입출력을 요청하고 block(PID)를 실행한다.**
   + block(PID)는 해당 프로세스를 대기 상태로 옮기고, **CPU 스케줄러는 새로운 프로세스를 실행 상태로 가져온다.**

- 대기 상태
    + 대기 상태(Blocking Status)는 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태이다.
    + 대기 상태의 프로세스는 입출력장치별로 마련된 큐에서 기다린다.
    + 입출력이 완료 되면 **인터럽트가 발생**하고, **대기 상태에 있는 여러 프로세스 중 해당 인터럽트로 깨어날 프로세스를 찾는데 이것이 wakeup(PID)**이다.

- 완료 상태
   + 완료 상태(Terminate Status)는 프로세스가 종료되는 상태이다.
   + 코드와 사용했던 데이터를 메모리에서 삭제하고 **프로세스 제어 블록을 폐기한다.**
   + 정상적인 종료는 exit()로 처리한다.
   + 오류나 비정상적으로 종료되는 강제 종료(Abort)를 만나면 **디버깅을 하기 위해 강제 종료 직전의 메모리 상태를 저장장치로 옮기는데 이를 코어 덤프(Core Dump)라고 한다.**

<br>

## 휴식 상태와 보류 상태
```
대부분의 프로세스는 생성, 준비, 실행, 대기, 완료 상태로 운영되며 이 다섯 가지 상태를
활성 상태(Active Status)라고 한다.

활성 상태를 제외한 특별한 상태 2가지가 있는데 알아보자.
```

- 휴식 상태
   + 휴식 상태(Pause Status)는 프로세스가 작업을 일시적으로 쉬고 있는 상태이다.
   + **사용하던 데이터가 메모리에 그대로 있고 프로세스 제어 블록도 유지되므로 프로세스는 멈춘 지점에서부터 재시작(Resume) 할 수 있다.

<br>

- 보류 상태
   + 보류 상태(Suspend Status)는 프로세스가 메모리에서 잠시 쫓겨난 상태로 휴식 상태와 차이가 있다.
   + 보류 상태와 비교하여 일반적인 프로세스 상태를 활성 상태라고 한다.
   + 보류 상태가 일어나는 이유는 주로 컴퓨터의 성능을 떨어뜨리거나 실행을 미루어도 큰 지장이 없다는 점이다.
      * 예시)
      * 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보낼 때
      * 프로그램에 오류가 있어서 실행을 미루어야 할 때
      * 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단될 때
      * 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
      * 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때

<br>

![SuspendStatus](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbf4d6d%2Fbtq1NuS4831%2Fdbvf4a9ah1kXaLugrMhrNK%2Fimg.png) 

- 보류 상태에 들어간 프로세스는 메모리 밖으로 쫓겨나 스왑 영역(Swap Area)에 보관된다.
  + 스왑 영역 : 메모리에서 쫓겨난 데이터가 임시로 보관되는 곳
- 보류 상태와 휴식 상태의 차이
  + 보류 상태 : 스왑 영역에 있는 상태이다.
  + 휴식 상태 : 프로세스가 메모리에 있으나 잠시 멈춘 상태이다.
- 보류 상태는 대기 상태에서 옮겨진 **보류 대기 상태(Block Suspend Status)**와 준비 상태에서 옮겨진 **보류 준비 상태(Ready Susmpend Status)**가 있다. 