# 2-2. CPU와 메모리

## CPU의 구성과 동작
---
### CPU의 기본 구성
- 산술논리 연산장치(ALU)
    + CPU에서 데이터를 연산하는 장치
    + 데이터의 +, -, *, / 같은 산술 연산 및 AND, OR 같은 논리 연산 수행
- 제어장치
    + CPU에서 작업을 지시하는 장치
- **레지스터**
    + CPU 내에 데이터를 임시로 보관하는 곳
<br><br>

### CPU의 명령어 처리 과정
<br>

```
int D2 = 2, D3 = 3, sum;
sum = D2 + D3;
```
#### - 소스코드 2-1) C언어로 작성한 덧셈 프로그램
<br>

- 소스코드 2-1은 변수 D2, D3, sum을 선언하고, D2에 저장되어 있는 데이터인 2와 D3에 저장되어 있는 데이터 3을 더해서 sum에 저장하는 명령어이다.

<br>

```
LOAD mem(100), register 2;
LOAD mem(120), register 3;
ADD register 5, register 2, register 3;
MOVE register 5, mem(160);
```
#### - 소스코드 2-2) 어셈블리어로 변환한 덧셈 프로그램
<br>

- 소스코드 2-1을 어셈블리어로 작성한 프로그램
- 1행 : 메모리 100번지에 있는 데이터(D2)를 레지스터 2로 가져온다.
- 2행 : 메모리 120번지에 있는 데이터(D3)를 레지스터 3로 가져온다.
- 3행 : 레지스터 2와 레지스터 3의 데이터를 더한 후, 레지스터 5에 저장한다.
- 4행 : 레지스터 5에 저장되어 있는 데이터를 메모리 160번지로 이동한다.
<br><br>

#### **명령어 처리에 대한 자세한 설명**
- CPU는 연산을 하기 위해 데이터를 CPU 내부에 있는 레지스터에 임시 저장함 (1~2행)
- ALU에서 레지스터에 저장된 두 데이터를 더하고, 결과값을 또 다른 레지스터에 저장함 (3행)
- 결과값을 레지스터에서 MEMORY로 옮김(4행)
- 이 모든 과정에서 제어장치는 명령어를 해석해서 제어 신호를 보냄
    + 제어 신호에 따라 CPU 내의 데이터 흐름이 조절됨
<br><br>

### 레지스터의 종류
<br>

#### 사용자 가시 레지스터
- 데이터 레지스터(DR, Data Register)
  + 메모리에서 가져온 데이터를 임시 보관하는 레지스터
  + CPU에 있는 대부분의 레지스터 = DR
  + 일반 레지스터, 범용 레지스터라고 불림

- 주소 레지스터(AR, Address Register)
  + 데이터 or 명령어가 저장된 메모리의 주소를 저장

<br>

#### 사용자 불가시 레지스터(특수 레지스터)
- 프로그램 카운터(PC, Program Counter)
  + 다음에 실행할 명령어의 주소를 저장
  + 저장한 주소를 제어장치에 알림
  + 명령어 포인터(Instruction Pointer)라고도 불림

<br>

- 명령어 레지스터(IR, Instruction Register)
  + 현재 실행중인 명령어를 저장
  + 제어장치는 IR에 있는 명령을 해석 한 후, 외부 장치에 제어 신호를 보냄

<br>

- 메모리 주소 레지스터(MAR, Memory Address Register)
  + 메모리에서 데이터를 가져오거나 혹은, 데이터를 보낼 때 주소를 지정하기 위해 사용
  + 메모리 관리자는 MAR에 저장되어 있는 메모리 주소를 통해 데이터를 가져오거나 보냄

<br>

- 메모리 버퍼 레지스터(MBR, Memory Buffer Register)
  + 메모리에서 가져온 데이터나 메모리로 옮겨 갈 데이터를 임시로 저장
  + 항상 MAR와 함께 동작

<br>

- 프로그램 상태 레지스터(PSR)
   + 연산 결과(양수, 음수)를 저장

```
LOAD mem(100), register 2;
```

1. 프로그램 카운터(PC)에는 현재 실행 중인 코드의 행 번호 1이 저장되고, 이 번호는 제어장치에 전송됨
2. 명령어 레지스터(IR)에는 명령어 'LOAD'가 탑재됨
3. 메모리 주소 레지스터(MAR)에 100이 저장되고, 메모리 관리자는 메모리 100번지에 저장된 값을 메모리 버퍼 레지스터(MBR)로 가져옴
4. 제어장치는 메모리 버퍼 레지스터(MBR)에 저장된 값을 레지스터 2로 옮김

<br>

### 버스의 종류

<br>

```
버스 : CPU와 메모리, 주변장치 간에 데이터를 주고받을 때 사용
```

- 제어 버스
  + 다음에 어떤 작업을 할지 지시하는 제어 신호가 오고 감
  + 데이터를 가져올 때 => 읽기 신호, 데이터를 옮길 때 => 쓰기 신호
  + CPU의 제어장치와 연결
  + 제어 버스의 신호는 CPU, 메모리, 주변장치와 **양방향**으로 오고 감

<br>

- 주소 버스
  + 위치 정보(주소)가 오고 가는 버스
  + CPU의 메모리 주소 레지스터(MAR)와 연결
  + 주소 버스는 **단방향**
  + CPU에서 메모리나 주변장치로 나가는 주소 정보는 있지만, 주소 버스를 통해 CPU로 전달되는 정보는 없음

<br>

- 데이터 버스
  + 데이터가 오고 가는 버스
  + 제어 버스 -> 주소 버스 -> 데이터 버스 순서
  + CPU의 메모리 버퍼 레지스터(MBR)와 연결
  + 데이터 버스는 **양방향**

<br><br>


## 메모리의 종류와 부팅
---
### 메모리 보호
- 일괄 작업 시스템에서는 메모리가 운영체제 영역과 사용자 영역으로 구분됨
- 일괄 작업 시스템에서 메모리 보호는 사용자 영역의 작업이 운영체제 영역으로 침범하지 못하도록 막는 것
- 현대의 운영체제는 시분할 기법을 사용하여 여러 프로그램을 동시에 실행 => 메모리 보호가 매우 중요해짐
- 메모리 보호를 위해 CPU는 현재 진행 중인 작업의 **메모리 시작 주소를 경계 레지스터(Bound Register)에 저장**함
  + 또한, 현재 진행중인 작업이 차지하고 있는 메모리의 크기 즉, 마지막 주소까지의 차이를 한계 레지스터(Limit Register)에 저장

<br>

- 메모리 시작 주소가 140이고, 차지하고 있는 메모리의 크기가 40인 작업 B를 실행한다고 가정
  + 작업 B의 메모리 시작 주소(140)와 작업이 차지하고 있는 메모리의 크기(40)를 각각 경계 레지스터와 한계 레지스터에 저장
  + 작업 B가 데이터를 읽거나 쓸 때마다 CPU는 해당 작업이 경계 레지스터와 한계 레지스터의 주소값 안에서 이루어지는지 검사함
  + 만약 범위를 벗어나면? **★ 인터럽트 발생 ★**
  + 인터럽트가 발생하면 모든 작업이 중단되고, CPU는 운영체제를 깨워서 인터럽트를 처리하도록 시킴
  + 메모리 영역을 벗어나서 발생한 인터럽트의 경우 => 운영체제가 프로그램을 강제 종료함

<br><br>

### 부팅
```
응용 프로그램은 운영체제가 메모리에 올려서 실행함
운영체제도 프로그램이다 => 메모리에 올라와야 실행됨
그럼 과연 운영체제는 어떻게 메모리에 올라갈까?
``` 

- 부팅 : 컴퓨터를 켰을 때 운영체제를 메모리에 올리는 과정
- 부팅과정
  1. 컴퓨터의 전원을 켜면 롬에 저장된 바이오스 실행
  2. 바이오스가 CPU, 메모리, 하드디스크, 키보드, 마우스와 같은 주요 하드웨어의 상태를 확인
       * 이상이 있을 경우, 본체에서 삐~ 소리와 함께 에러 문구 출력
  3. 하드디스크의 마스터 부트 레코드(MBR, Master Boot Record)에 저장된 부트스트랩(Bootstrap) 실행
       * 마스터 부트 레코드(MBR, Master Boot Record) : 하드디스크의 첫번째 섹터, 부트스트랩이 저장되어 있음
       * 부트스트랩(Bootstrap) : 운영체제를 실행하기 위한 코드. 작은 프로그램임 => 결국, 프로그램임으로 메모리에 올라가야 실행한다.
  4. 부트스트랩이 메모리에 올라와서 실행되면, 하드디스크에 저장된 운영체제를 메모리로 불러와서 실행함
       * 마스터 부트 레코드가 손상되면 운영체제를 실행할 수 없음 => 좋은 공격 대상