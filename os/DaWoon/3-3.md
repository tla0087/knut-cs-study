# 프로세스의 연산

## 프로세스의 구조
---
- 코드 영역
  + 프로그램의 본문이 기술된 곳, 텍스트 영역(Text Area)라고도 부름
  + 코드 영역에 탑재된 코드는 **읽기 전용**으로 처리된다.

- 데이터 영역
  + 코드가 실행되면서 사용하는 변수, 파일 등의 각종 데이터를 모아놓는 곳
  + 이 영역의 내용은 읽기, 쓰기가 가능하다.
  + 단, 상수로 선언된 변수는 읽기 전용

- 스택 영역
  + 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳
  + 사용자에겐 보이지 않는다.

<br><br>

## 프로세스의 생성과 복사
---
### fork() 시스템 호출의 개념
- fork() 시스템 호출
- 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수이다.
- 커널에서 제공된다.
- 사용하면 실행 중인 프로세스와 똑같은 프로세스가 하나 더 만들어진다.
- 예시)
  + 한글 프로그램으로 문서 작업을 하다가 새로운 한글 프로그램을 하나 더 실행시켰을 때
    * 운영체제가 새로운 한글 프로그램을 실행시키지 않는다.
        - 새로운 한글 프로그램을 메모리에 올리고, 그에 대한 새로운 PCB를 생성하는 것이 아니라는 뜻
    * fork() 시스템 호출을 사용하여 기존의 한글 프로그램을 복사하는 것이다.
- 프로세스를 복사할 때 **기존의 프로세스는 부모 프로세스**
- **새로 생긴 프로세스는 자식 프로세스**
- 두 프로세스는 **부모-자식 관계로 연결**된다.

- 정리
```
fork() 시스템 호출은 실행 중인 프로세스를 복사하는 함수이다. 이때 실행하던 프로세스는
부모 프로세스, 새로 생긴 프로세스는 자식 프로세스로서 부모-자식 관계가 된다.
```

<br>

### fork() 시스템 호출의 동작 과정
![fork_process](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fp0KWt%2FbtqIsL7kK13%2FEx3eNPHU4dPJOIyxHWkf70%2Fimg.png)

- fork() 시스템 호출을 하면 **PCB을 포함한 부모 프로세스 영역의 대부분이 자식 프로세스에 복사**되어 똑같은 프로세스가 만들어진다.
- 단, PCB의 일부가 변경된다.
  1. 프로세스 구분자(PID)가 바뀐다.
  2. 부모 프로세스와 자식 프로세스가 차지하고 있는 메모리의 위치가 다르므로 메모리 관련 정보가 바뀐다.
  3. 부모 프로세스 구분자(PPID)와 자식 프로세스 구분자(CPID)가 바뀐다. (-1은 존재하지 않는다는 의미)

<br>

### fork() 시스템 호출의 장점
1. 프로세스의 생성 속도가 빠르다.
   + HDD로부터 프로그램을 새로 가져오지 않고 기존 메모리에서 복사하기 떄문에 훨씬 빠르다.
2. 추가 작업 없이 자원을 상속할 수 있다.
   + 부모 프로세스가 사용하던 모든 자원을 추가 작업 없이 자식 프로세스에 상속할 수 있다.
3. 시스템 관리를 효율적으로 할 수 있다.
   + 자식 프로세스를 종료하면 자식이 사용하던 자원(메모리 영역, 파일, 하드웨어 등)을 부모 프로세스가 정리 할 수 있기 때문이다.

<br><br>

## 프로세스의 전환
---
### exec() 시스템 호출의 개념
- exec() 시스템 호출 : 기존의 프로세스를 새로운 프로세스로 전환하는 함수이다.
- fork()와 exec()의 다른점
  + fork() : ***새로운 프로세스를 복사하는*** 시스템 호출이다.
  + exec() : ***프로세스는 그대로 둔 채 내용만 바꾸는*** 시스템 호출이다. exec() 시스템 호출을 하면 현재의 프로세스가 완전히 다른 프로세스로 전환된다. (프로세스의 내용 변경)
- exec() 시스템 호출을 사용하는 목적은 **프로세스의 구조체를 재활용**하기 위함이다.
- 프로세스를 생성하기 위해서는 메모리를 할당받아야 하고 PCB를 생성하는 과정이 필요하지만, exec() 시스템 호출을 사용하면 **이미 만들어진 PCB, 메모리 영역, 부모-자식 관계를 그대로 사용 할 수 있다.**
- 새로운 코드 영역만 가져오면 되기 때문에 운영체제의 작업이 수월하다.

<br>

- 정리
```
exec() 시스템 호출은 이미 만들어진 프로세스의 구조를 재활용하는 것이다.
```

<br>

### exec() 시스템 호출의 동작 과정
![exec_process](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FXJ6DN%2FbtqIkt05maL%2FlglEZVZgMTkWluKhpGUB90%2Fimg.png)

- exec() 시스템 호출을 하면 코드 영역에 있는 기존의 내용을 지우고 새로운 코드로 변경한다.
- 데이터 영역이 새로운 변수로 채워진다.
- 스택 영역이 리셋된다.
- PCB의 내용 중 PID, PPID, CPID, 메모리 관련 사항 등은 변하지 않는다.
- 프로그램 카운터(PC) 값을 비롯한 각종 레지스터와 사용한 파일 정보가 모두 리셋된다.
- exec() 시스템 호출은 기존의 프로세스 구조를 그대로 둔 채 내용만 바꾸어 새로 실행하는 것이다.
- 각종 프로세스 구분자(PID, PPID, CPID)만 남겨두고 프로세스의 나머지 내용을 새로운 것으로 바꾼다.

<br>

### exec() 시스템 호출의 예
```
#include <stdio.h>
#include <unistd.h>

void main()
{
    int pid;
    
    pid = fork();

    if(pid < 0){
        printf("Error");
        exit(-1);
    }

    else if (pid == 0){ /* child */
        execlp("mplayer", "mplayer", NULL);
        exit(0);
    }

    else{
        wate(NULL);
        printf("mplayer Terminated");
        exit(0);
    }
}
```
### 부모 프로세스

<br>

```
/* mplayer  - music player */

void main()
{




    mplayer 실행 코드





}
```
### 자식 프로세스(exec() 실행)

<br>

- 부모 프로세스는 fork() 문을 실행하여 자식 프로세스를 생성
- wait() 문을 실행하여 자식 프로세스가 끝날 때까지 대기
  + wait() 문은 자식 프로세스와의 동기화를 위한 코드이다.
  + 자식 프로세스가 끝날 때까지 부모 프로세스가 기다리는 문이다.
- 새로 막 생성된 자식 프로세스는 부모 프로세스의 코드 내용과 같다.
- 그러나, execlp("mplayer", "mplayer", NULL)이 실행되는 순간 자식 프로세스의 코드 영역이 mplayer의 코드로 바뀌어 처음부터 다시 실행된다.
- mplayer의 실행이 끝나면 부모 프로세스의 wait()가 있는 곳으로 돌아오고, 부모 프로세스는 'mplayer Terminated'를 출력한다.
- exec() 시스템 호출을 사용하여 새로운 프로세스로 전환하더라도 PCB의 각종 프로세스 구분자(PID, PPID, CPID)는 변경되지 않는다. => 프로세스가 종료된 후에도 부모 프로세스로 돌아올 수 있음

<br>

## 프로세스의 계층 구조
---
### 유닉스의 프로세스 계층 구조
![UNIX_process_structure](https://blog.kakaocdn.net/dn/bB5QPG/btqwyQNA4HZ/UP6dte5IC7xINVN4YPzwf1/img.png)
- init 프로세스는 전체 프로세스의 출발점이 된다.
- 운영체제는 **프로세스를 효율적으로 관리**하기 위해 init 프로세스를 만든 다음 **나머지 프로세스를 init 프로세스의 자식으로 만들었다.**
- init 프로세스는 일반 사용자 프로세스의 맨 위에 위치한다.
- fork(), exec() 시스템 호출을 이용하여 자식 프로세스를 만든다.

### 프로세스 계층 구조의 장점
```
프로세스의 계층 구조는 동시에 여러 작업을 처리하고, 종료된 프로세스의 자원을
회수하는데 유용하다.
```

<br>

![precess_recycle](https://ifh.cc/g/i9bhUH.jpg)
### 프로세스의 재사용

<br>

- 여러 작업의 동시 처리
  + 상황 제시) 사용자 3명이 동시에 컴퓨터에 접속하려는 상황
    * login 프로세스는 인증을 거쳐 컴퓨터에 접속하는 과정을 처리하는 프로세스이다. 
    * 하지만 login 프로세스는 한번에 1명만 처리할 수 있다. 
    * 이런 상황을 해결하기 위해, fork() 시스템 호출로 login 프로세스를 여러 개 만들어 사용자에게 나누어준다.
    * 새로운 사용자가 들어올 때마다 이러한 작업을 반복하면 여러 사용자를 동시에 처리할 수 있다.
  + login 프로세스를 통과하고 나면 shell 프로세스가 필요하다.
    * 작업을 마친 login 프로세스를 메모리에서 내리고, PCB를 삭제한 다음에 shell 프로세스를 메모리에 올리고, PCB를 새롭게 생성하는건 비효율적이다.
    * 이때 exec() 시스템 호출을 사용하여 login 프로세스의 구조를 shell 프로세스로 재활용하면 자원을 효율적으로 관리할 수 있다.
    * 또한, 기존의 부모-자식 관계도 유지할 수 있다.
  + shell 프로세스에서 명령어로 응용 프로그램을 실행할 때도 fork()와 exec() 시스템 호출을 이용한다.
    *  사용자 2가 mplayer 프로그램을 실행하면 shell 프로세스는 fork() 시스템 호출로 새로운 자식 shell 프로세스를 만든 후, exec() 시스템 호출을 사용하여 mplayer 프로세스로 바꾼다.

<br>  

- 용이한 자원 회수
  + 프로세스를 계층 구조로 만들면 프로세스 간의 책임 관계가 분명해져서 시스템을 관리하기가 수월해진다.
  + 프로세스가 작업을 마쳐서 그 프로세스가 사용하던 자원을 회수할 때 특히 편리하다.
  + 만약, 모든 프로세스가 독립적으로 만들어지면 프로세스가 종료될 때마다 운영체제가 직접 자원을 회수해야 할 것이다.

<br>

### 고아 프로세스
- 부모 프로세스는 **자원을 회수하기 위해** 자식 프로세스가 끝날 때까지 기다려야한다.
- 그런데 부모 프로세스가 먼저 종료되거나 자식 프로세스가 비정상적으로 종료되어 부모 프로세스에 연락이 안 되는 경우도 있다.
- 이런 문제가 발생하면 자식 프로세스가 종료되지 않거나, 종료되었는데도 사용하던 자원이 그대로 남게 된다.
- 프로세스가 종료된 후에도 비정상적으로 남아 있는 프로세스를 고아 프로세스(Orphan Process) 혹은 좀비 프로세스(Zombie Process)라고 한다.
  + 고아 프로세스 : 부모 프로세스가 자식 프로세스보다 먼저 죽는 경우에 발생한다.
  + 좀비 프로세스 : 자식 프로세스가 종료 됐음에도 부모가 뒷처리(자원 회수)를 하지 않을 때 발생한다.
- 위 두 가지의 현상을 예방하기 위해 운영체제는 반환되지 못한 자원을 회수하는 자원 회수를 주기적으로 해야한다.
